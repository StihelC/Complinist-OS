#!/usr/bin/env tsx
/**
 * Spacing Analysis Tool
 *
 * Analyzes the current layout generated by layout-templates.ts
 * and detects overlapping nodes to recommend spacing adjustments
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface Node {
  id: string;
  type: string;
  position: { x: number; y: number };
  data: any;
  parentId?: string;
  style?: any;
}

interface LayoutedTemplate {
  id: string;
  name: string;
  nodes: Node[];
}

const DEVICE_WIDTH = 140;
const DEVICE_HEIGHT = 150;
const LABEL_BUFFER = 30; // Extra space for labels below nodes

/**
 * Check if two rectangles overlap
 */
function rectanglesOverlap(
  r1: { x: number; y: number; width: number; height: number },
  r2: { x: number; y: number; width: number; height: number },
  buffer: number = 0
): boolean {
  return !(
    r1.x + r1.width + buffer < r2.x ||
    r2.x + r2.width + buffer < r1.x ||
    r1.y + r1.height + buffer < r2.y ||
    r2.y + r2.height + buffer < r1.y
  );
}

/**
 * Analyze spacing within a boundary
 */
function analyzeBoundarySpacing(
  boundaryName: string,
  childNodes: Node[],
  globalDeviceImageSize: number = 55
): {
  overlaps: number;
  minHorizontalGap: number;
  minVerticalGap: number;
  details: string[];
} {
  const overlaps: string[] = [];
  let minHGap = Infinity;
  let minVGap = Infinity;

  for (let i = 0; i < childNodes.length; i++) {
    for (let j = i + 1; j < childNodes.length; j++) {
      const nodeA = childNodes[i];
      const nodeB = childNodes[j];

      // Calculate dimensions with scaling
      const scaleA = ((nodeA.data as any).deviceImageSize ?? globalDeviceImageSize) / 55;
      const scaleB = ((nodeB.data as any).deviceImageSize ?? globalDeviceImageSize) / 55;

      const rectA = {
        x: nodeA.position.x,
        y: nodeA.position.y,
        width: Math.round(DEVICE_WIDTH * scaleA),
        height: Math.round(DEVICE_HEIGHT * scaleA) + LABEL_BUFFER,
      };

      const rectB = {
        x: nodeB.position.x,
        y: nodeB.position.y,
        width: Math.round(DEVICE_WIDTH * scaleB),
        height: Math.round(DEVICE_HEIGHT * scaleB) + LABEL_BUFFER,
      };

      // Check overlap
      if (rectanglesOverlap(rectA, rectB)) {
        const nameA = nodeA.data?.name || nodeA.id;
        const nameB = nodeB.data?.name || nodeB.id;
        overlaps.push(`${nameA} ‚Üî ${nameB}`);
      }

      // Calculate gaps
      const hGap = Math.min(
        Math.abs(rectA.x + rectA.width - rectB.x),
        Math.abs(rectB.x + rectB.width - rectA.x)
      );

      const vGap = Math.min(
        Math.abs(rectA.y + rectA.height - rectB.y),
        Math.abs(rectB.y + rectB.height - rectA.y)
      );

      if (hGap < minHGap) minHGap = hGap;
      if (vGap < minVGap) minVGap = vGap;
    }
  }

  return {
    overlaps: overlaps.length,
    minHorizontalGap: minHGap === Infinity ? 0 : Math.round(minHGap),
    minVerticalGap: minVGap === Infinity ? 0 : Math.round(minVGap),
    details: overlaps,
  };
}

/**
 * Analyze all templates
 */
function analyzeTemplates(imageSizes: number[] = [55, 100]): void {
  const dataPath = path.join(__dirname, '../.data/layouted-templates.json');

  if (!fs.existsSync(dataPath)) {
    console.error('‚ùå Layouted templates not found. Run: npm run layout:templates');
    return;
  }

  const templates: LayoutedTemplate[] = JSON.parse(fs.readFileSync(dataPath, 'utf-8'));

  console.log('üîç Spacing Analysis Report\n');
  console.log('='.repeat(80));

  for (const imageSize of imageSizes) {
    console.log(`\nüìê Global Device Image Size: ${imageSize}%`);
    console.log('='.repeat(80));

    for (const template of templates) {
      console.log(`\nüìÅ Template: ${template.name}`);
      console.log('-'.repeat(80));

      const boundaries = template.nodes.filter((n) => n.type === 'boundary');
      let totalOverlaps = 0;

      for (const boundary of boundaries) {
        const childNodes = template.nodes.filter((n) => n.parentId === boundary.id);

        if (childNodes.length === 0) continue;

        const analysis = analyzeBoundarySpacing(boundary.data?.label || boundary.id, childNodes, imageSize);

        const boundaryName = boundary.data?.label || boundary.id;
        const status = analysis.overlaps === 0 ? '‚úÖ' : '‚ùå';

        console.log(`\n  ${status} ${boundaryName}`);
        console.log(`     Nodes: ${childNodes.length}`);
        console.log(`     Overlaps: ${analysis.overlaps}`);
        console.log(`     Min H-Gap: ${analysis.minHorizontalGap}px`);
        console.log(`     Min V-Gap: ${analysis.minVerticalGap}px`);

        if (analysis.overlaps > 0) {
          console.log(`     Overlapping pairs:`);
          analysis.details.forEach((detail) => console.log(`       - ${detail}`));
          totalOverlaps += analysis.overlaps;
        }
      }

      const templateStatus = totalOverlaps === 0 ? '‚úÖ PASS' : `‚ùå FAIL (${totalOverlaps} overlaps)`;
      console.log(`\n  ${templateStatus}`);
    }
  }

  console.log('\n' + '='.repeat(80));
  console.log('\nüí° Recommendations:\n');
  console.log('If overlaps are detected:');
  console.log('  1. Increase nodesep/ranksep in src/lib/layout/dagreLayout.ts');
  console.log('  2. Regenerate layouts: npm run layout:templates');
  console.log('  3. Re-run analysis: npm run analyze:spacing');
  console.log('  4. Repeat until all overlaps are resolved');
  console.log('\nTarget spacing (to prevent overlaps):');
  console.log('  - Horizontal (nodesep): ‚â• 150px (for 100% image size)');
  console.log('  - Vertical (ranksep): ‚â• 200px (for 100% image size + labels)');
  console.log('='.repeat(80));
}

// Run analysis
analyzeTemplates([55, 100]);
