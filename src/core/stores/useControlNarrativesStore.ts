import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import type { AppEdge, AppNode, ControlFamily, ControlNarrative, NistBaseline } from '@/lib/utils/types';
import { getAllControlsWithBaselineFlags, groupControlsByFamily } from '@/lib/controls/controlCatalog';
import { db } from '@/core/database/client';
import { analyzeTopology } from '@/lib/topology/topologyAnalyzer';
import { generateNarrativeForControl } from '@/lib/utils/narrativeGenerators';
import { recommendImplementation } from '@/lib/ai/implementationAssistant';
import { getFlowStoreStateSafe } from './flowStoreAccessor';

type ControlNarrativeUpdate = Pick<
  ControlNarrative,
  'control_id' | 'narrative' | 'system_implementation' | 'implementation_status'
>;

interface LoadParams {
  baseline: NistBaseline;
  projectId: number;
}

interface BatchGenerationProgress {
  total: number;
  completed: number;
  current: string | null;
  errors: Array<{ controlId: string; error: string }>;
}

interface ControlNarrativesState {
  items: Record<string, ControlNarrative>;
  families: ControlFamily[];
  baseline: NistBaseline;
  searchTerm: string;
  showOnlyApplicable: boolean;
  hiddenCustomCount: number;
  dirtyIds: Set<string>;
  dirtyCount: number;
  loading: boolean;
  saving: boolean;
  generating: boolean;
  generationProgress: BatchGenerationProgress | null;
  error: string | null;
  projectId: number | null;
  loadControls: (params: LoadParams) => Promise<void>;
  changeBaseline: (newBaseline: NistBaseline) => Promise<void>;
  setSearchTerm: (term: string) => void;
  setShowOnlyApplicable: (value: boolean) => void;
  updateNarrative: (controlId: string, text: string) => void;
  updateStatus: (controlId: string, status: string) => void;
  resetControl: (controlId: string) => void;
  saveNarratives: () => Promise<{ saved: number; cleared: number } | void>;
  saveSingleControl: (controlId: string) => Promise<{ success: boolean; error?: string }>;
  getNarrativesForBaseline: () => Record<string, ControlNarrative>;
  autoPopulateFromTopology: (nodes: AppNode[], edges: AppEdge[]) => Promise<void>;
  getAutoGeneratedNarrative: (
    controlId: string,
    nodes: AppNode[],
    edges: AppEdge[],
  ) => Promise<string | null>;
  generateAllWithAI: (options?: { onlyEmpty?: boolean; controlIds?: string[] }) => Promise<{ generated: number; errors: number }>;
  cancelGeneration: () => void;
  // Internal state (not exposed in interface but used internally)
  _cancelGeneration?: boolean;
}

const DEFAULT_BASELINE: NistBaseline = 'MODERATE';
const AUTO_GENERATED_CONTROLS = ['SC-7', 'AC-2', 'CM-8'];

export const useControlNarrativesStore = create<ControlNarrativesState>()(
  devtools((set, get) => ({
    items: {},
    families: [],
    baseline: DEFAULT_BASELINE,
    searchTerm: '',
    showOnlyApplicable: true,
    hiddenCustomCount: 0,
    dirtyIds: new Set(),
    dirtyCount: 0,
    loading: false,
    saving: false,
    generating: false,
    generationProgress: null,
    error: null,
    projectId: null,
    _cancelGeneration: false,

    async loadControls({ baseline, projectId }) {
      if (!projectId) {
        set({ error: 'A project must be selected before loading control narratives.' });
        return;
      }

      set({ loading: true, error: null });

      try {
        const catalog = await getAllControlsWithBaselineFlags(baseline);
        const savedNarratives = await db.loadControlNarratives(projectId);
        const showOnlyApplicable = get().showOnlyApplicable;

        const items: Record<string, ControlNarrative> = {};
        Object.entries(catalog.items).forEach(([controlId, control]) => {
          items[controlId] = { ...control };
        });

        savedNarratives.forEach((record) => {
          const control = items[record.control_id];
          if (!control) return;
          const systemImplementation = record.system_implementation ?? record.narrative ?? '';
          control.system_implementation = systemImplementation ?? '';
          control.implementation_status = record.implementation_status ?? undefined;
          control.isCustom = Boolean(systemImplementation?.trim() || control.implementation_status);
          control.wasCustom = control.isCustom;
        });

        const hiddenCustomCount = calculateHiddenCustomCount(items);

        set({
          items,
          families: buildFamilies(items, get().searchTerm, showOnlyApplicable),
          baseline,
          dirtyIds: new Set(),
          dirtyCount: 0,
          loading: false,
          projectId,
          hiddenCustomCount,
        });
      } catch (error) {
        set({
          error: error instanceof Error ? error.message : 'Failed to load control catalog.',
          loading: false,
        });
      }
    },

    setSearchTerm(term) {
      set((state) => ({
        searchTerm: term,
        families: buildFamilies(state.items, term, state.showOnlyApplicable),
      }));
    },

    setShowOnlyApplicable(value) {
      set((state) => ({
        showOnlyApplicable: value,
        families: buildFamilies(state.items, state.searchTerm, value),
      }));
    },

    async changeBaseline(newBaseline) {
      const { projectId, baseline } = get();
      if (!projectId) {
        set({ error: 'A project must be selected before changing baseline.' });
        return;
      }

      if (newBaseline === baseline) {
        return; // No change needed
      }

      // Prevent duplicate baseline updates
      const state = get();
      if (state.loading) {
        console.log('[ControlNarratives] Baseline update already in progress - skipping duplicate');
        return;
      }

      set({ loading: true, error: null });

      try {
        // Update project baseline in database
        await db.updateProjectBaseline(projectId, newBaseline);

        // Update currentProject in flow store to reflect the change
        // Using the flowStoreAccessor to avoid circular dependencies
        const flowStore = getFlowStoreStateSafe();
        if (flowStore?.currentProject && flowStore.currentProject.id === projectId) {
          flowStore.setCurrentProject({
            ...flowStore.currentProject,
            baseline: newBaseline,
          });
        }

        // Reload controls with new baseline
        await get().loadControls({ baseline: newBaseline, projectId });
      } catch (error) {
        set({
          error: error instanceof Error ? error.message : 'Failed to change baseline.',
          loading: false,
        });
      }
    },

    updateNarrative(controlId, text) {
      set((state) => {
        const control = state.items[controlId];
        if (!control) return state;
        const updatedControl: ControlNarrative = {
          ...control,
          system_implementation: text,
          isCustom: Boolean(text.trim() || control.implementation_status),
        };
        const dirtyIds = new Set(state.dirtyIds);
        if (!updatedControl.isCustom && !control.wasCustom) {
          dirtyIds.delete(controlId);
        } else {
          dirtyIds.add(controlId);
        }
        const items = {
          ...state.items,
          [controlId]: updatedControl,
        };
        return {
          items,
          families: buildFamilies(items, state.searchTerm, state.showOnlyApplicable),
          dirtyIds,
          dirtyCount: dirtyIds.size,
          hiddenCustomCount: calculateHiddenCustomCount(items),
        };
      });
    },

    updateStatus(controlId, status) {
      set((state) => {
        const control = state.items[controlId];
        if (!control) return state;
        const items = {
          ...state.items,
          [controlId]: {
            ...control,
            implementation_status: status,
            isCustom: Boolean(control.system_implementation?.trim() || status),
          },
        };
        const dirtyIds = new Set(state.dirtyIds).add(controlId);
        return {
          items,
          families: buildFamilies(items, state.searchTerm, state.showOnlyApplicable),
          dirtyIds,
          dirtyCount: dirtyIds.size,
          hiddenCustomCount: calculateHiddenCustomCount(items),
        };
      });
    },

    resetControl(controlId) {
      set((state) => {
        const control = state.items[controlId];
        if (!control) return state;

        const resetControl: ControlNarrative = {
          ...control,
          narrative: control.default_narrative,
          system_implementation: '',
          implementation_status: undefined,
          isCustom: false,
        };

        const dirtyIds = new Set(state.dirtyIds);
        if (control.wasCustom) {
          dirtyIds.add(controlId);
        } else {
          dirtyIds.delete(controlId);
        }

        const items = {
          ...state.items,
          [controlId]: resetControl,
        };

        return {
          items,
          families: buildFamilies(items, state.searchTerm, state.showOnlyApplicable),
          dirtyIds,
          dirtyCount: dirtyIds.size,
          hiddenCustomCount: calculateHiddenCustomCount(items),
        };
      });
    },

    async saveNarratives() {
      const { projectId, dirtyIds, items } = get();
      if (!projectId || dirtyIds.size === 0) {
        return;
      }

      set({ saving: true, error: null });

      try {
        const dirtyControls = Array.from(dirtyIds)
          .map((id) => items[id])
          .filter(Boolean) as ControlNarrative[];

        const updates: ControlNarrativeUpdate[] = dirtyControls
          .filter((control) => control.isCustom)
          .map((control) => ({
            control_id: control.control_id,
            narrative: control.system_implementation ?? '',
            system_implementation: control.system_implementation ?? '',
            implementation_status: control.implementation_status,
          }));

        const resets = dirtyControls.filter((control) => !control.isCustom);

        if (updates.length > 0) {
          await db.saveControlNarratives(projectId, updates);
        }

        if (resets.length > 0) {
          await Promise.all(
            resets.map((control) => db.resetControlNarrative(projectId, control.control_id)),
          );
        }

        set((state) => {
          const updatedItems = { ...state.items };
          updates.forEach(({ control_id }) => {
            if (updatedItems[control_id]) {
              updatedItems[control_id] = {
                ...updatedItems[control_id],
                wasCustom: true,
                isCustom: true,
              };
            }
          });
          resets.forEach((control) => {
            if (updatedItems[control.control_id]) {
              updatedItems[control.control_id] = {
                ...updatedItems[control.control_id],
                wasCustom: false,
                isCustom: false,
                system_implementation: '',
                implementation_status: undefined,
              };
            }
          });

          return {
            items: updatedItems,
            families: buildFamilies(updatedItems, state.searchTerm, state.showOnlyApplicable),
            dirtyIds: new Set(),
            dirtyCount: 0,
            saving: false,
            hiddenCustomCount: calculateHiddenCustomCount(updatedItems),
          };
        });

        return { saved: updates.length, cleared: resets.length };
      } catch (error) {
        set({
          error: error instanceof Error ? error.message : 'Failed to save control narratives.',
          saving: false,
        });
      }
    },

    async saveSingleControl(controlId) {
      const { projectId, items, dirtyIds } = get();
      if (!projectId) {
        return { success: false, error: 'No project selected' };
      }

      const control = items[controlId];
      if (!control) {
        return { success: false, error: 'Control not found' };
      }

      // Check if control has unsaved changes
      if (!dirtyIds.has(controlId) && !control.isCustom) {
        return { success: true }; // Nothing to save
      }

      set({ saving: true, error: null });

      try {
        const update: ControlNarrativeUpdate = {
          control_id: control.control_id,
          narrative: control.system_implementation ?? '',
          system_implementation: control.system_implementation ?? '',
          implementation_status: control.implementation_status,
        };

        await db.saveSingleControlNarrative(projectId, controlId, update.system_implementation || '', update.implementation_status);

        // Update state - remove from dirtyIds and mark as saved
        set((state) => {
          const updatedDirtyIds = new Set(state.dirtyIds);
          updatedDirtyIds.delete(controlId);

          const updatedItems = { ...state.items };
          if (updatedItems[controlId]) {
            updatedItems[controlId] = {
              ...updatedItems[controlId],
              wasCustom: true,
              isCustom: true,
            };
          }

          return {
            items: updatedItems,
            families: buildFamilies(updatedItems, state.searchTerm, state.showOnlyApplicable),
            dirtyIds: updatedDirtyIds,
            dirtyCount: updatedDirtyIds.size,
            saving: false,
            hiddenCustomCount: calculateHiddenCustomCount(updatedItems),
          };
        });

        return { success: true };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Failed to save control narrative.';
        set({
          error: errorMessage,
          saving: false,
        });
        return { success: false, error: errorMessage };
      }
    },

    getNarrativesForBaseline() {
      return get().items;
    },

    async autoPopulateFromTopology(nodes, edges) {
      if (!nodes.length) {
        set({ error: 'Add devices to the topology before auto-populating narratives.' });
        return;
      }

      try {
        const intelligence = analyzeTopology(nodes, edges);
        set((state) => {
          const updatedItems = { ...state.items };
          const dirtyIds = new Set(state.dirtyIds);
          let hasChanges = false;
          const generatedAt = new Date().toISOString();

          AUTO_GENERATED_CONTROLS.forEach((controlId) => {
            const target = updatedItems[controlId];
            const narrative = generateNarrativeForControl(controlId, intelligence);
            if (!target || !narrative) return;

            hasChanges = true;
            dirtyIds.add(controlId);

            updatedItems[controlId] = {
              ...target,
              system_implementation: narrative,
              isCustom: true,
              autoGenerated: true,
              autoGeneratedAt: generatedAt,
              referencedDevices: getReferencedDevices(controlId, intelligence),
              referencedBoundaries: getReferencedBoundaries(controlId, intelligence),
            };
          });

          if (!hasChanges) {
            return state;
          }

          return {
            items: updatedItems,
            families: buildFamilies(updatedItems, state.searchTerm, state.showOnlyApplicable),
            dirtyIds,
            dirtyCount: dirtyIds.size,
            error: null,
            hiddenCustomCount: calculateHiddenCustomCount(updatedItems),
          };
        });
      } catch (error) {
        set({
          error: error instanceof Error ? error.message : 'Failed to analyze topology for auto-population.',
        });
      }
    },

    async getAutoGeneratedNarrative(controlId, nodes, edges) {
      if (!nodes.length) return null;
      const intelligence = analyzeTopology(nodes, edges);
      return generateNarrativeForControl(controlId.toUpperCase(), intelligence);
    },

    cancelGeneration() {
      set({ _cancelGeneration: true } as any);
    },

    async generateAllWithAI(options = {}) {
      const { onlyEmpty = true, controlIds } = options;
      const { items, projectId } = get();

      if (!projectId) {
        set({ error: 'A project must be selected before generating narratives.' });
        return { generated: 0, errors: 0 };
      }

      // Determine which controls to generate for
      let controlsToGenerate = Object.values(items).filter((control) => {
        // Only applicable controls
        if (!control.isApplicableToBaseline) return false;

        // If specific controlIds provided, filter to those
        if (controlIds && controlIds.length > 0) {
          if (!controlIds.includes(control.control_id)) return false;
        }

        // If onlyEmpty, skip controls that already have narratives
        if (onlyEmpty) {
          const hasNarrative = control.system_implementation?.trim() &&
            !control.system_implementation.includes('[TODO');
          if (hasNarrative) return false;
        }

        return true;
      });

      if (controlsToGenerate.length === 0) {
        set({ error: 'No controls need narrative generation.' });
        return { generated: 0, errors: 0 };
      }

      // Initialize progress
      set({
        generating: true,
        _cancelGeneration: false,
        generationProgress: {
          total: controlsToGenerate.length,
          completed: 0,
          current: null,
          errors: [],
        },
        error: null,
      } as any);

      let generated = 0;
      const errors: Array<{ controlId: string; error: string }> = [];

      // Process controls sequentially (LLM can only handle one at a time)
      for (const control of controlsToGenerate) {
        // Check for cancellation
        if ((get() as any)._cancelGeneration) {
          break;
        }

        // Update current control
        set({
          generationProgress: {
            ...get().generationProgress!,
            current: control.control_id,
          },
        });

        try {
          const result = await recommendImplementation({
            controlId: control.control_id,
            controlTitle: control.title,
            nistReference: control.default_narrative || '',
            existingImplementation: control.system_implementation,
            projectId,
          });

          if (result.recommendedImplementation) {
            // Update the narrative in the store
            get().updateNarrative(control.control_id, result.recommendedImplementation);
            generated++;
          }
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : 'Unknown error';
          errors.push({ controlId: control.control_id, error: errorMsg });
        }

        // Update progress
        set({
          generationProgress: {
            ...get().generationProgress!,
            completed: get().generationProgress!.completed + 1,
            errors,
          },
        });
      }

      // Finalize
      set({
        generating: false,
        generationProgress: null,
        error: errors.length > 0
          ? `Generated ${generated} narratives with ${errors.length} errors`
          : null,
      });

      return { generated, errors: errors.length };
    },
  })),
);

function buildFamilies(
  items: Record<string, ControlNarrative>,
  searchTerm: string,
  showOnlyApplicable: boolean = true,
): ControlFamily[] {
  const term = searchTerm.trim().toLowerCase();
  const controls = Object.values(items).filter((control) => {
    // Filter by baseline applicability if enabled
    if (showOnlyApplicable && !control.isApplicableToBaseline) {
      return false;
    }
    // Filter by search term
    if (!term) return true;
    const haystack = `${control.control_id} ${control.title} ${control.default_narrative} ${control.system_implementation || ''}`.toLowerCase();
    return haystack.includes(term);
  });
  return groupControlsByFamily(controls);
}

function calculateHiddenCustomCount(items: Record<string, ControlNarrative>): number {
  return Object.values(items).filter(
    (control) => !control.isApplicableToBaseline && (control.isCustom || control.wasCustom),
  ).length;
}

function getReferencedDevices(controlId: string, intelligence: ReturnType<typeof analyzeTopology>): string[] {
  if (controlId === 'SC-7') {
    return intelligence.boundaries.zones.flatMap((zone) => zone.devices);
  }

  if (controlId === 'AC-2' || controlId === 'CM-8') {
    return intelligence.devices.details.map((detail) => detail.id);
  }

  return [];
}

function getReferencedBoundaries(
  controlId: string,
  intelligence: ReturnType<typeof analyzeTopology>,
): string[] {
  if (controlId === 'SC-7') {
    return intelligence.boundaries.zones.map((zone) => zone.id);
  }
  return [];
}

